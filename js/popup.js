/**
 * Class for creating single task objects
 */
class task {
	/*------------------------------------------------------------------------*//**
	 * Constructs the object.
	 *
	 * @param      {string}  title         The title of the task
	 * @param      {string}  description   The description of the task
	 * @param      {number}  reminderType  Alarm / Notification / Both / None
	 * @param      {string}  date          The date of the task
	 * @param      {string}  time          The time of the task
	 */
	constructor(title,description,reminderType,date,time) {
		/**
		 * If the date and time of the task is a time in the future the notif_shown value
		 * is set to 0, else 1. Because on a future time and date will require that it 
		 * show notifications. This value will be given to the 'notification_shown'
		 * flag to each task object.
		 *
		 * @type       {number}
		 */
		let notif_shown = Math.ceil(new Date(date + " " + time).getTime()/1000) > Math.ceil(new Date().getTime()/1000) ? 0:1;

		this.title = title;
		this.description = description;
		this.reminderType = reminderType;
		this.date = date;
		this.time = time;
		this.taskObj = {};
		this.done = 0;
		this.notification_shown = notif_shown;
	}
	/**
	 * Saves the task to chrome storage
	 */
	saveTask(){
		this.taskObj = {
			"title": this.title,
			"description": this.description,
			"reminderType": this.reminderType,
			"date": this.date,
			"time": this.time,
			"done": this.done,
			"notification_shown":this.notification_shown
		};
		let time = new Date();
		time = time.getTime();
		let key = "task_"+time;
		let taskObjTmp = {};
		taskObjTmp[key] = this.taskObj;

		chrome.storage.sync.set(taskObjTmp, () => {
			// After saving the message to chrome storage a confirmation
			// message is shown to the user. The following is the markup of
			// that message.
			let messageMarkup = `
				<div class="alert alert-success alert-dismissable">
				  <a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>
				  <strong>Success!</strong> Task Saved.
				</div>
			`;
			$('#holder').prepend(messageMarkup);
		});
	}
}
/**
 * class {taskList} - creates object of all the tasks in chrome's storage
 */
class taskList {
	/*------------------------------------------------------------------------*//**
	 * Constructs the object.
	 *
	 * @param      {string}  items   object of all tasks in chrome's memory
	 */
	constructor(items) {
		this.tasksArr = [];
		this.upcomingTasksArr = [];
		this.pendingTasksArr = [];
		this.completedTasksArr = [];
		/**
		 * looping over every task object and adding a timestamp attribute to
		 * each of them generated by the date and time values present in them.
		 * Also adding the 'id' attribute by which it is stored in chrome's
		 * storage. Finally pushing each task object into an array.
		 */
		for(let item in items) {
			let year,month,day,hours,minutes;
			items[item]['timestamp'] = new Date(items[item]['date'] + " " + items[item]['time']).getTime();
			items[item]['id'] = item; 
			this.tasksArr.push(items[item]);
		}
	}
	/*------------------------------------------------------------------------*//**
	 * Updates the array containing all the tasks. Called when chrome fires an
	 * change event to its storage, i.e. a task has been added, deleted or
	 * modified.
	 *
	 * @param      {string}  items   object of all tasks in chrome's storage
	 */
	updateTasksArr(items) {
		this.tasksArr = [];
		/**
		 * looping over every task object and adding a timestamp attribute to
		 * each of them generated by the date and time values present in them.
		 * Also adding the 'id' attribute by which it is stored in chrome's
		 * storage. Finally pushing each task object into an array.
		 */
		for(let item in items) {
			let year,month,day,hours,minutes;
			items[item]['timestamp'] = new Date(items[item]['date'] + " " + items[item]['time']).getTime();
			items[item]['id'] = item; 
			this.tasksArr.push(items[item]);
		}
	}
	/*------------------------------------------------------------------------*//**
	 * Gets all tasks, i.e. the all tasks array
	 *
	 * @return     {array}  All tasks.
	 */
	getAllTasks() {
		return this.tasksArr;
	}
	/*------------------------------------------------------------------------*//**
	 * Gets the total number of tasks.
	 *
	 * @return     {array}  Total number of tasks
	 */
	getAllTasksNumber() {
		return this.tasksArr.length;
	}
	/*------------------------------------------------------------------------*//**
	 * Gets the upcoming tasks.
	 *
	 * @return     {array}  The upcoming tasks.
	 */
	getUpcomingTasks(){
		this.upcomingTasksArr = [];
		let currentTimeStamp = Date.now();
		for (var i = 0; i < this.tasksArr.length; i++) {
			if((currentTimeStamp <= this.tasksArr[i]['timestamp'] || isNaN(this.tasksArr[i]['timestamp'])) && this.tasksArr[i].done == 0) {
				this.upcomingTasksArr.push(this.tasksArr[i]);
			}
		}
		return this.upcomingTasksArr;
	}
	/*------------------------------------------------------------------------*//**
	 * Gets the total number upcoming tasks.
	 *
	 * @return     {array}  The number of upcoming tasks.
	 */
	getUpcomingTasksNumber(){
		this.getUpcomingTasks();
		return this.upcomingTasksArr.length;
	}
	/*------------------------------------------------------------------------*//**
	 * Gets the completed tasks.
	 *
	 * @return     {array}  The completed tasks.
	 */
	getCompletedTasks(){
		this.completedTasksArr = [];
		for (var i = 0; i < this.tasksArr.length; i++) {
			if(this.tasksArr[i].done == 1) {
				this.completedTasksArr.push(this.tasksArr[i]);
			}
		}
		return this.completedTasksArr;
	}
	/*------------------------------------------------------------------------*//**
	 * Gets the total number of completed tasks.
	 *
	 * @return     {array}  The number of completed tasks.
	 */
	getCompletedTasksNumber(){
		this.getCompletedTasks();
		return this.completedTasksArr.length;
	}
	/*------------------------------------------------------------------------*//**
	 * Gets the pending tasks.
	 *
	 * @return     {array}  The pending tasks.
	 */
	getPendingTasks(){
		this.pendingTasksArr = [];
		let currentTimeStamp = Date.now();
		for (var i = 0; i < this.tasksArr.length; i++) {
			if(currentTimeStamp >= this.tasksArr[i]['timestamp'] && this.tasksArr[i].done == 0) {
				this.pendingTasksArr.push(this.tasksArr[i]);
			}
		}
		return this.pendingTasksArr;
	}
	/*------------------------------------------------------------------------*//**
	 * Gets the number of pending tasks.
	 *
	 * @return     {array}  The total number of pending tasks.
	 */
	getPendingTasksNumber(){
		this.getPendingTasks();
		return this.pendingTasksArr.length;
	}
}
/**
 * Updates the task number of each task type in the popup
 *
 * @param      {number}  allTasksNumber        All tasks number
 * @param      {number}  upcomingTasksNumber   The upcoming tasks number
 * @param      {number}  pendingTaksNumber     The pending taks number
 * @param      {number}  completedTasksNumber  The completed tasks number
 */
function updateTasksNumber(allTasksNumber, upcomingTasksNumber, pendingTaksNumber, completedTasksNumber) {
	$('#allTasks span').text(allTasksNumber);
	$('#upcomingTasks span').text(upcomingTasksNumber);
	$('#pendingTaks span').text(pendingTaksNumber);
	$('#completedTasks span').text(completedTasksNumber);
}
/**
 * Function to validate the required fields in the pop up form to add a new task
 *
 * @return     {boolean}  returns whether validation passes or fails
 */
function validator() {
	let flag = 0;
	if($("#title").val() == ''){
		$("#err_title").css('display','block');
		flag = 1;
	} else {
		$("#err_title").css('display','none');
	}
	if($("input[name=reminderType]:checked").val() != 4) {
		if($('#date').val() != '' && $('#time').val() != ''){
			$("#dateTime").css('display','none');
		} else {
			$("#dateTime").css('display','block');
			flag = 1;
		}
	} else {
		$("#dateTime").css('display','none');
	}
	if(flag == 0){
		return true;
	} else {
		return false;
	}
}
$(document).ready(function(){
	let allTasks;
	// Getting a list of all tasks and calling updateTaskNumber() with
	// the number of different types of task to be updated in the popup
	chrome.storage.sync.get(null, (items) => {
					allTasks = new taskList(items);
					updateTasksNumber(
							allTasks.getAllTasksNumber(), 
							allTasks.getUpcomingTasksNumber(),
							allTasks.getPendingTasksNumber(),
							allTasks.getCompletedTasksNumber());
					// Hiding the loader image
					$('#counts img').hide();
			});
	$('a#allTasks').click(() => {
		chrome.tabs.create({'url':chrome.runtime.getURL('html/tasks.html')});
	});
	$('a#upcomingTasks').click(() => {
		chrome.tabs.create({'url':chrome.runtime.getURL('html/tasks.html#upcomingTasks')});
	});
	$('a#pendingTaks').click(() => {
		chrome.tabs.create({'url':chrome.runtime.getURL('html/tasks.html#pendingTasks')});
	});
	$('a#completedTasks').click(() => {
		chrome.tabs.create({'url':chrome.runtime.getURL('html/tasks.html#completedTasks')});
	});
	// Showing or hiding the date and time section according to the selected
	//  reminder type
	$('input[name=reminderType]').click(() => {
		let val = $("input[name=reminderType]:checked").val();
		if (val == 1 || val == 2 || val == 3) {
			$('#reminderDateTime').css('display','block');
		} else {
			$('#reminderDateTime').css('display','none');
		}
	});
	/**
	 * On clickin gthe Add button all the form data is taken and is converted into an
	 * object of the task class and then saved to chrome's storage.
	 */
	$('#submit').click(() => {
		if(validator()) {
			let title = $('#title').val();
			let description = $('#description').val();
			let reminderType = $("input[name=reminderType]:checked").val();
			// Manually setting ther date and time fields to null if reminder type is 4,
			// that is 'none'
			if(reminderType == 4){
				$('#date').val('');
				$('#time').val('');
			}
			let date = $('#date').val();
			let time = $('#time').val();
	
			// After extracting the values and setting them to different variables
			//  setting the form filed's values to the defaults
			$('#title').val('');
			$('#description').val('');
			$("input[name=reminderType]").attr('checked', false);
			$('#date').val('');
			$('#time').val('');
	
			// Creating a new object of the task class using the task data provided
			// by the user.
			let newTask = new task(title,description,reminderType,date,time);
			// Saving the task object
			newTask.saveTask();
			// Reloading all the tasks from chrome's storage and recalculating and updating
			// the number of different types of tasks.
			chrome.storage.sync.get(null, (items) => {
				allTasks.updateTasksArr(items);
				updateTasksNumber(
					allTasks.getAllTasksNumber(), 
					allTasks.getUpcomingTasksNumber(),
					allTasks.getPendingTasksNumber(),
					allTasks.getCompletedTasksNumber());
			});
		}
	});
});
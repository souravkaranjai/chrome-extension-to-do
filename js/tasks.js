/**
 * class {taskList} - creates object of all the tasks in chrome's storage
 */
class taskList {
	/*------------------------------------------------------------------------*//**
	 * Constructs the object.
	 *
	 * @param      {string}  items   object of all tasks in chrome's memory
	 */
	constructor(items) {
		this.tasksArr = [];
		this.upcomingTasksArr = [];
		this.pendingTasksArr = [];
		this.completedTasksArr = [];
		/**
		 * looping over every task object and adding a timestamp attribute to
		 * each of them generated by the date and time values present in them.
		 * Also adding the 'id' attribute by which it is stored in chrome's
		 * storage. Finally pushing each task object into an array.
		 */
		for(let item in items) {
			let year,month,day,hours,minutes;
			items[item]['timestamp'] = new Date(items[item]['date'] + " " + items[item]['time']).getTime();
			items[item]['id'] = item;
			this.tasksArr.push(items[item]);
		}
	}
	/*------------------------------------------------------------------------*//**
	 * Updates the array containing all the tasks. Called when chrome fires an
	 * change event to its storage, i.e. a task has been added, deleted or
	 * modified.
	 *
	 * @param      {string}  items   object of all tasks in chrome's storage
	 */
	updateTasksArr(items) {
		this.tasksArr = [];
		/**
		 * looping over every task object and adding a timestamp attribute to
		 * each of them generated by the date and time values present in them.
		 * Also adding the 'id' attribute by which it is stored in chrome's
		 * storage. Finally pushing each task object into an array.
		 */
		for(let item in items) {
			let year,month,day,hours,minutes;
			items[item]['timestamp'] = new Date(items[item]['date'] + " " + items[item]['time']).getTime();
			items[item]['id'] = item; 
			this.tasksArr.push(items[item]);
		}
	}
	/*------------------------------------------------------------------------*//**
	 * Gets all tasks, i.e. the all tasks array
	 *
	 * @return     {array}  All tasks.
	 */
	getAllTasks() {
		return this.tasksArr;
	}
	/*------------------------------------------------------------------------*//**
	 * Gets the total number of tasks.
	 *
	 * @return     {array}  Total number of tasks
	 */
	getAllTasksNumber() {
		return this.tasksArr.length;
	}
	/*------------------------------------------------------------------------*//**
	 * Gets the upcoming tasks.
	 *
	 * @return     {array}  The upcoming tasks.
	 */
	getUpcomingTasks(){
		this.upcomingTasksArr = [];
		let currentTimeStamp = Date.now();
		for (var i = 0; i < this.tasksArr.length; i++) {
			if((currentTimeStamp <= this.tasksArr[i]['timestamp'] || isNaN(this.tasksArr[i]['timestamp'])) && this.tasksArr[i].done == 0) {
				this.upcomingTasksArr.push(this.tasksArr[i]);
			}
		}
		return this.upcomingTasksArr;
	}
	/*------------------------------------------------------------------------*//**
	 * Gets the total number upcoming tasks.
	 *
	 * @return     {array}  The number of upcoming tasks.
	 */
	getUpcomingTasksNumber(){
		this.getUpcomingTasks();
		return this.upcomingTasksArr.length;
	}
	/*------------------------------------------------------------------------*//**
	 * Gets the completed tasks.
	 *
	 * @return     {array}  The completed tasks.
	 */
	getCompletedTasks(){
		this.completedTasksArr = [];
		for (var i = 0; i < this.tasksArr.length; i++) {
			if(this.tasksArr[i].done == 1) {
				this.completedTasksArr.push(this.tasksArr[i]);
			}
		}
		return this.completedTasksArr;
	}
	/*------------------------------------------------------------------------*//**
	 * Gets the total number of completed tasks.
	 *
	 * @return     {array}  The number of completed tasks.
	 */
	getCompletedTasksNumber(){
		this.getCompletedTasks();
		return this.completedTasksArr.length;
	}
	/*------------------------------------------------------------------------*//**
	 * Gets the pending tasks.
	 *
	 * @return     {array}  The pending tasks.
	 */
	getPendingTasks(){
		this.pendingTasksArr = [];
		let currentTimeStamp = Date.now();
		for (var i = 0; i < this.tasksArr.length; i++) {
			if(currentTimeStamp >= this.tasksArr[i]['timestamp'] && this.tasksArr[i].done == 0) {
				this.pendingTasksArr.push(this.tasksArr[i]);
			}
		}
		return this.pendingTasksArr;
	}
	/*------------------------------------------------------------------------*//**
	 * Gets the number of pending tasks.
	 *
	 * @return     {array}  The total number of pending tasks.
	 */
	getPendingTasksNumber(){
		this.getPendingTasks();
		return this.pendingTasksArr.length;
	}
	/*------------------------------------------------------------------------*//**
	 * Returns the HTML of a single upcoming task
	 *
	 * @param      {string}  id           Task id as stored in chrome storage
	 * @param      {string}  title        The title of the task
	 * @param      {string}  description  The description of the task
	 * @param      {string}  date         The date of the task
	 * @param      {string}  time         The time of the task
	 * @param      {number}  done         Whether the task is marked as finished
	 *                                    or not
	 * @return     {string}  The HTML of a single upcoming task.
	 */
	getSingleTemplateUpcoming(id,title,description,date,time,done){
		date = date != ''?'('+date+')':'';
		return `
			<div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 task-template">
				<div class="panel panel-primary">
				  <div class="panel-heading">${title}</div>
				  <div class="panel-body">${description}</div>
				  <div class="panel-footer">
				  	 ${time}
				  	 ${date}
				  	<button class="btn btn-info editBtn" data-id="${id}">Edit</button>
				  	<button class="btn btn-warning deleteBtn" data-id="${id}">Delete</button>
				  	<button class="btn btn-success doneBtn" data-id="${id}">${done==0?'Done':'Not done'}</button>
				  </div>
				</div>
			</div>
		`;
	}
	/*------------------------------------------------------------------------*//**	
	 * Returns the HTML of a single pending task
	 *
	 * @param      {string}  id           Task id as stored in chrome storage
	 * @param      {string}  title        The title of the task
	 * @param      {string}  description  The description of the task
	 * @param      {string}  date         The date of the task
	 * @param      {string}  time         The time of the task
	 * @param      {number}  done         Whether the task is marked as finished
	 *                                    or not
	 * @return     {string}  The HTML of a single pending task.
	 */
	getSingleTemplatePending(id,title,description,date,time,done){
		date = date != ''?'('+date+')':'';
		return `
			<div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 task-template">
				<div class="panel panel-danger">
				  <div class="panel-heading">${title}</div>
				  <div class="panel-body">${description}</div>
				  <div class="panel-footer">
				  	 ${time}
				  	 ${date}
				  	<button class="btn btn-info editBtn" data-id="${id}">Edit</button>
				  	<button class="btn btn-warning deleteBtn" data-id="${id}">Delete</button>
				  	<button class="btn btn-success doneBtn" data-id="${id}">${done==0?'Done':'Not done'}</button>
				  </div>
				</div>
			</div>
		`;
	}
	/*------------------------------------------------------------------------*//**
	 * Returns the HTML of a single completed task
	 *
	 * @param      {string}  id           Task id as stored in chrome storage
	 * @param      {string}  title        The title of the task
	 * @param      {string}  description  The description of the task
	 * @param      {string}  date         The date of the task
	 * @param      {string}  time         The time of the task
	 * @param      {number}  done         Whether the task is marked as finished
	 *                                    or not
	 * @return     {string}  The HTML of a single completed task.
	 */
	getSingleTemplateCompleted(id,title,description,date,time,done){
		date = date != ''?'('+date+')':'';
		return `
			<div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 task-template">
				<div class="panel panel-success">
				  <div class="panel-heading">${title}</div>
				  <div class="panel-body">${description}</div>
				  <div class="panel-footer">
				  	 ${time}
				  	 ${date}
				  	<button class="btn btn-info editBtn" data-id="${id}">Edit</button>
				  	<button class="btn btn-warning deleteBtn" data-id="${id}">Delete</button>
				  	<button class="btn btn-success doneBtn" data-id="${id}">${done==0?'Done':'Not done'}</button>
				  </div>
				</div>
			</div>
		`;
	}
	/*------------------------------------------------------------------------*//**
	 * Returns the HTML of all upcoming tasks
	 *
	 * @return     {string}  The HTML of all upcoming tasks.
	 */
	getTemplateStringUpcoming() {
		let returnString = "";
		for (var i = 0; i < this.getUpcomingTasksNumber(); i++) {
			returnString += this.getSingleTemplateUpcoming(
									this.upcomingTasksArr[i]['id'],
									this.upcomingTasksArr[i]['title'],
									this.upcomingTasksArr[i]['description'],
									this.upcomingTasksArr[i]['date'],
									this.upcomingTasksArr[i]['time'],
									this.upcomingTasksArr[i]['done']
									);
		}
		return returnString;
	}
	/*------------------------------------------------------------------------*//**
	 * Returns the HTML of all pending tasks
	 *
	 * @return     {string}  The HTML of all pending tasks.
	 */
	getTemplateStringPending() {
		let returnString = "";
		for (var i = 0; i < this.getPendingTasksNumber(); i++) {
			returnString += this.getSingleTemplatePending(
										this.pendingTasksArr[i]['id'],
										this.pendingTasksArr[i]['title'],
										this.pendingTasksArr[i]['description'],
										this.pendingTasksArr[i]['date'],
										this.pendingTasksArr[i]['time'],
										this.pendingTasksArr[i]['done']
									);
		}
		return returnString;
	}
	/*------------------------------------------------------------------------*//**
	 * Returns the HTML of all completed tasks
	 *
	 * @return     {string}  The HTML of all completed tasks.
	 */
	getTemplateStringCompleted() {
		let returnString = "";
		for (var i = 0; i < this.getCompletedTasksNumber(); i++) {
			returnString += this.getSingleTemplateCompleted(
										this.completedTasksArr[i]['id'],
										this.completedTasksArr[i]['title'],
										this.completedTasksArr[i]['description'],
										this.completedTasksArr[i]['date'],
										this.completedTasksArr[i]['time'],
										this.completedTasksArr[i]['done']
									);
		}
		return returnString;
	}
	/*------------------------------------------------------------------------*//**
	 * Returns the HTML of all tasks
	 *
	 * @return     {string}  The HTML of all tasks.
	 */
	getTemplateStringAll() {
		let returnString = "";
		returnString += this.getTemplateStringUpcoming();
		returnString += this.getTemplateStringPending();
		returnString += this.getTemplateStringCompleted();
		return returnString;
	}
	/*------------------------------------------------------------------------*//**
	 * Returns the updated HTML of the entire page. Called when a user clicks 
	 * on a menu in the navigation.
	 *
	 * @return     {string}  The complete HTML for the current view (upcoming
	 * tasks / pending tasks / completed tasks / all tasks)
	 * 
	 */
	updateView(){
		let hash = location.hash;
		let tempString;
		switch(hash) {
			case '#upComingTasks':
				tempString = this.getTemplateStringUpcoming();
				break;
			case '#pendingTasks':
				tempString = this.getTemplateStringPending();
				break;
			case '#completedTasks':
				tempString = this.getTemplateStringCompleted();
				break;
			default:
				tempString = this.getTemplateStringAll();
		}		
		return tempString;
	}
}
/**
 * Function that marks a task as done or undone based on its previous value
 */
function markDoneUndone() {
	let id = $(this).attr('data-id');
	let tmpObj = {};
	tmpObj[id] = 1;
	chrome.storage.sync.get(id, (items) => {
		items[id]['done'] = items[id]['done']==0?1:0;
		chrome.storage.sync.set(items, () => {

		});
	});
}
/**
 * Function to delete a task by id
 */
function deleteTask() {
	let id = $(this).attr('data-id');
	chrome.storage.sync.remove(id, (items) => {
		
	});
}
/**
 * Function to activate the edit task modal by grabbing all information of the task
 * that has been clicked on to be edited
 */
function editTaskModal(){
	id = $(this).attr('data-id');
	chrome.storage.sync.get(id, (items) => {
		$('#myModal #id').val(id);
		$('#myModal #done').val(items[id]['done']);
		$('#myModal #title').val(items[id]['title']);
		$('#myModal #description').val(items[id]['description']);
		$('#myModal .radio-inline input[value='+items[id]['reminderType']+']').attr('checked',true);
		$('#myModal .radio-inline input[value='+items[id]['reminderType']+']').click();
		$("#date").val(items[id]['date']);
		$("#time").val(items[id]['time']);
	});
	$('#myModal').modal();
}
/**
 * Function to highlight the menu on the navbar clicked on by the user
 */
function highlightMenu(){
	let hash = location.hash;
	let tempString;
	switch(hash) {
		case '#upComingTasks':
			$('.menu').removeClass('active');
			$('.menu:nth-child(2)').addClass('active');
			break;
		case '#pendingTasks':
			$('.menu').removeClass('active');
			$('.menu:nth-child(3)').addClass('active');
			break;
		case '#completedTasks':
			$('.menu').removeClass('active');
			$('.menu:nth-child(4)').addClass('active');
			break;
		default:
			$('.menu').removeClass('active');
			$('.menu:nth-child(1)').addClass('active');
	}	
}
$(document).ready(function(){
	highlightMenu();
	let taskView;
	/**
	 * Getting a list of all tasks and creating an objject of the taskList class
	 * and assigning click handlers to the edit delete and done buttons
	 */
	chrome.storage.sync.get(null, (items) => {
		this.taskView = new taskList(items);
		$('#tasks').html(this.taskView.updateView());
		$('.doneBtn').click(markDoneUndone);
		$('.deleteBtn').click(deleteTask);
		$('.editBtn').click(editTaskModal);
	});
	/**
	 * Event listener to listen in on window hash changes so that the view can be
	 * updated by calling the appropriate function
	 *
	 */
	window.onhashchange = () => {
		$('#tasks').html(this.taskView.updateView());
		$('.doneBtn').click(markDoneUndone);
		$('.deleteBtn').click(deleteTask);
		$('.editBtn').click(editTaskModal);
		highlightMenu();
	}
	/**
	 * Adding a event listener to chrome storage so that any changes made to any task,
	 * addition, deletion or modification by any scripts in the plugin, will result in 
	 * fetching the task list and updating the view with the new task list
	 */
	chrome.storage.onChanged.addListener(() => {
		chrome.storage.sync.get(null, (items) => {
			this.taskView = new taskList(items);
			$('#tasks').html(this.taskView.updateView());
			$('.doneBtn').click(markDoneUndone);
			$('.deleteBtn').click(deleteTask);
			$('.editBtn').click(editTaskModal);
		});
	});
	// Showing or hiding the date and time section according to the selected
	//  reminder type
	$('input[name=reminderType]').click(() => {
		let val = $("input[name=reminderType]:checked").val();
		if (val == 1 || val == 2 || val == 3) {
			$('#reminderDateTime').css('display','block');
		} else {
			$('#reminderDateTime').css('display','none');
		}
	});
	/**
	 * On clickin gthe Add button all the form data of the edit task modal
	 *  is taken and is converted into an object of the task class and then saved to 
	 *  chrome's storage.
	 */
	$("#submit").click(function(){
		let id = $('#id').val();
		let done = $('#done').val();
		let title = $('#title').val();
		let description = $('#description').val();
		let reminderType = $("input[name=reminderType]:checked").val();
		// Manually setting ther date and time fields to null if reminder type is 4,
		// that is 'none'
		if(reminderType == 4){
			$('#date').val('');
			$('#time').val('');
		}
		let date = $('#date').val();
		let time = $('#time').val();

		/**
		 * If the date and time of the task is a time in the future the notif_shown value
		 * is set to 0, else 1. Because on a future time and date will require that it 
		 * show notifications. This value will be given to the 'notification_shown'
		 * flag to each task object.
		 *
		 * @type       {number}
		 */
		let notif_shown = Math.ceil(new Date(date + " " + time).getTime()/1000) > Math.ceil(new Date().getTime()/1000) ? 0:1;

		/**
		 * Creating the modified task object.
		 *
		 * @type       {object}
		 */
		let taskObj = {};
		taskObj[id] = {
			"title": title,
			"description": description,
			"reminderType": reminderType,
			"date": date,
			"time": time,
			"done": done,
			notification_shown:notif_shown
		};
		// Saving the edited tsk object
		chrome.storage.sync.set(taskObj, (items) => {
			let messageMarkup = `
				<div class="alert alert-success alert-dismissable">
				  <a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>
				  <strong>Success!</strong> Task Edited Successfully.
				</div>
			`;
			$('#myModal .modal-body').prepend(messageMarkup);
		});
	});
	/**
	 * Adding an event listener to the document so that whenever the tasks.html page
	 * loses focus and get back focus again we can load the tasks from chrome storage 
	 * and update the view accordingly.
	 */
	document.addEventListener('visibilitychange', function(){
	    if(!(document.hidden)){
	    	chrome.storage.sync.get(null, (items) => {
	    		this.taskView = new taskList(items);
	    		$('#tasks').html(this.taskView.updateView());
	    		$('.doneBtn').click(markDoneUndone);
	    		$('.deleteBtn').click(deleteTask);
	    		$('.editBtn').click(editTaskModal);
	    	});
	    }
	});
});